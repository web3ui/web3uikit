{"version":3,"file":"SourceMapper.js","sourceRoot":"","sources":["../../src/collector/SourceMapper.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport { SourceMapConsumer, RawSourceMap, MappingItem, Position } from 'source-map';\nimport { IExtractorMessageOptions } from '../api/ExtractorMessage';\nimport { FileSystem, InternalError, JsonFile, NewlineKind } from '@rushstack/node-core-library';\n\ninterface ISourceMap {\n  sourceMapConsumer: SourceMapConsumer;\n\n  // SourceMapConsumer.originalPositionFor() is useless because the mapping contains numerous gaps,\n  // and the API provides no way to find the nearest match.  So instead we extract all the mapping items\n  // and search them using SourceMapper._findNearestMappingItem().\n  mappingItems: MappingItem[];\n}\n\ninterface IOriginalFileInfo {\n  // Whether the .ts file exists\n  fileExists: boolean;\n\n  // This is used to check whether the guessed position is out of bounds.\n  // Since column/line numbers are 1-based, the 0th item in this array is unused.\n  maxColumnForLine: number[];\n}\n\nexport class SourceMapper {\n  // Map from .d.ts file path --> ISourceMap if a source map was found, or null if not found\n  private _sourceMapByFilePath: Map<string, ISourceMap | null> = new Map<string, ISourceMap | null>();\n\n  // Cache the FileSystem.exists() result for mapped .ts files\n  private _originalFileInfoByPath: Map<string, IOriginalFileInfo> = new Map<string, IOriginalFileInfo>();\n\n  /**\n   * If the `IExtractorMessageOptions` refers to a `.d.ts` file, look for a `.d.ts.map` and\n   * if possible update the coordinates to refer to the original `.ts` file.\n   */\n  public updateExtractorMessageOptions(options: IExtractorMessageOptions): void {\n    if (!options.sourceFilePath) {\n      return;\n    }\n\n    if (!FileSystem.exists(options.sourceFilePath)) {\n      // Sanity check\n      throw new InternalError('The referenced path was not found: ' + options.sourceFilePath);\n    }\n\n    let sourceMap: ISourceMap | null | undefined = this._sourceMapByFilePath.get(options.sourceFilePath);\n\n    if (sourceMap === undefined) {\n      // Normalize the path and redo the lookup\n      const normalizedPath: string = FileSystem.getRealPath(options.sourceFilePath);\n\n      sourceMap = this._sourceMapByFilePath.get(normalizedPath);\n      if (sourceMap !== undefined) {\n        // Copy the result from the normalized to the non-normalized key\n        this._sourceMapByFilePath.set(options.sourceFilePath, sourceMap);\n      } else {\n        // Given \"folder/file.d.ts\", check for a corresponding \"folder/file.d.ts.map\"\n        const sourceMapPath: string = normalizedPath + '.map';\n        if (FileSystem.exists(sourceMapPath)) {\n          // Load up the source map\n          const rawSourceMap: RawSourceMap = JsonFile.load(sourceMapPath) as RawSourceMap;\n\n          const sourceMapConsumer: SourceMapConsumer = new SourceMapConsumer(rawSourceMap);\n          const mappingItems: MappingItem[] = [];\n\n          // Extract the list of mapping items\n          sourceMapConsumer.eachMapping(\n            (mappingItem: MappingItem) => {\n              mappingItems.push({\n                ...mappingItem,\n                // The \"source-map\" package inexplicably uses 1-based line numbers but 0-based column numbers.\n                // Fix that up proactively so we don't have to deal with it later.\n                generatedColumn: mappingItem.generatedColumn + 1,\n                originalColumn: mappingItem.originalColumn + 1\n              });\n            },\n            this,\n            SourceMapConsumer.GENERATED_ORDER\n          );\n\n          sourceMap = { sourceMapConsumer, mappingItems };\n        } else {\n          // No source map for this filename\n          sourceMap = null;\n        }\n\n        this._sourceMapByFilePath.set(normalizedPath, sourceMap);\n        if (options.sourceFilePath !== normalizedPath) {\n          // Add both keys to the map\n          this._sourceMapByFilePath.set(options.sourceFilePath, sourceMap);\n        }\n      }\n    }\n\n    if (sourceMap === null) {\n      // No source map for this filename\n      return;\n    }\n\n    // Make sure sourceFileLine and sourceFileColumn are defined\n    if (options.sourceFileLine === undefined) {\n      options.sourceFileLine = 1;\n    }\n    if (options.sourceFileColumn === undefined) {\n      options.sourceFileColumn = 1;\n    }\n\n    const nearestMappingItem: MappingItem | undefined = SourceMapper._findNearestMappingItem(\n      sourceMap.mappingItems,\n      {\n        line: options.sourceFileLine,\n        column: options.sourceFileColumn\n      }\n    );\n\n    if (nearestMappingItem === undefined) {\n      // No mapping for this location\n      return;\n    }\n\n    const mappedFilePath: string = path.resolve(\n      path.dirname(options.sourceFilePath),\n      nearestMappingItem.source\n    );\n\n    // Does the mapped filename exist?  Use a cache to remember the answer.\n    let originalFileInfo: IOriginalFileInfo | undefined = this._originalFileInfoByPath.get(mappedFilePath);\n    if (originalFileInfo === undefined) {\n      originalFileInfo = {\n        fileExists: FileSystem.exists(mappedFilePath),\n        maxColumnForLine: []\n      };\n\n      if (originalFileInfo.fileExists) {\n        // Read the file and measure the length of each line\n        originalFileInfo.maxColumnForLine = FileSystem.readFile(mappedFilePath, {\n          convertLineEndings: NewlineKind.Lf\n        })\n          .split('\\n')\n          .map((x) => x.length + 1); // +1 since columns are 1-based\n        originalFileInfo.maxColumnForLine.unshift(0); // Extra item since lines are 1-based\n      }\n\n      this._originalFileInfoByPath.set(mappedFilePath, originalFileInfo);\n    }\n\n    if (!originalFileInfo.fileExists) {\n      // Don't translate coordinates to a file that doesn't exist\n      return;\n    }\n\n    // The nearestMappingItem anchor may be above/left of the real position, due to gaps in the mapping.  Calculate\n    // the delta and apply it to the original position.\n    const guessedPosition: Position = {\n      line: nearestMappingItem.originalLine + options.sourceFileLine - nearestMappingItem.generatedLine,\n      column:\n        nearestMappingItem.originalColumn + options.sourceFileColumn - nearestMappingItem.generatedColumn\n    };\n\n    // Verify that the result is not out of bounds, in cause our heuristic failed\n    if (\n      guessedPosition.line >= 1 &&\n      guessedPosition.line < originalFileInfo.maxColumnForLine.length &&\n      guessedPosition.column >= 1 &&\n      guessedPosition.column <= originalFileInfo.maxColumnForLine[guessedPosition.line]\n    ) {\n      options.sourceFilePath = mappedFilePath;\n      options.sourceFileLine = guessedPosition.line;\n      options.sourceFileColumn = guessedPosition.column;\n    } else {\n      // The guessed position was out of bounds, so use the nearestMappingItem position instead.\n      options.sourceFilePath = mappedFilePath;\n      options.sourceFileLine = nearestMappingItem.originalLine;\n      options.sourceFileColumn = nearestMappingItem.originalColumn;\n    }\n  }\n\n  // The `mappingItems` array is sorted by generatedLine/generatedColumn (GENERATED_ORDER).\n  // The _findNearestMappingItem() lookup is a simple binary search that returns the previous item\n  // if there is no exact match.\n  private static _findNearestMappingItem(\n    mappingItems: MappingItem[],\n    position: Position\n  ): MappingItem | undefined {\n    if (mappingItems.length === 0) {\n      return undefined;\n    }\n\n    let startIndex: number = 0;\n    let endIndex: number = mappingItems.length - 1;\n\n    while (startIndex <= endIndex) {\n      const middleIndex: number = startIndex + Math.floor((endIndex - startIndex) / 2);\n\n      const diff: number = SourceMapper._compareMappingItem(mappingItems[middleIndex], position);\n\n      if (diff < 0) {\n        startIndex = middleIndex + 1;\n      } else if (diff > 0) {\n        endIndex = middleIndex - 1;\n      } else {\n        // Exact match\n        return mappingItems[middleIndex];\n      }\n    }\n\n    // If we didn't find an exact match, then endIndex < startIndex.\n    // Take endIndex because it's the smaller value.\n    return mappingItems[endIndex];\n  }\n\n  private static _compareMappingItem(mappingItem: MappingItem, position: Position): number {\n    const diff: number = mappingItem.generatedLine - position.line;\n    if (diff !== 0) {\n      return diff;\n    }\n    return mappingItem.generatedColumn - position.column;\n  }\n}\n"]}
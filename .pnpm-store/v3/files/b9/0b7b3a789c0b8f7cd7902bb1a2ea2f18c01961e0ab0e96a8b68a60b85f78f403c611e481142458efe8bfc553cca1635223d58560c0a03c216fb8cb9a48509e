{"version":3,"file":"Async.js","sourceRoot":"","sources":["../src/Async.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/**\n * Options for controlling the parallelism of asynchronous operations.\n *\n * @remarks\n * Used with {@link Async.mapAsync} and {@link Async.forEachAsync}.\n *\n * @beta\n */\nexport interface IAsyncParallelismOptions {\n  /**\n   * Optionally used with the  {@link Async.mapAsync} and {@link Async.forEachAsync}\n   * to limit the maximum number of concurrent promises to the specified number.\n   */\n  concurrency?: number;\n}\n\n/**\n * Utilities for parallel asynchronous operations, for use with the system `Promise` APIs.\n *\n * @beta\n */\nexport class Async {\n  /**\n   * Given an input array and a `callback` function, invoke the callback to start a\n   * promise for each element in the array.  Returns an array containing the results.\n   *\n   * @remarks\n   * This API is similar to the system `Array#map`, except that the loop is asynchronous,\n   * and the maximum number of concurrent promises can be throttled\n   * using {@link IAsyncParallelismOptions.concurrency}.\n   *\n   * If `callback` throws a synchronous exception, or if it returns a promise that rejects,\n   * then the loop stops immediately.  Any remaining array items will be skipped, and\n   * overall operation will reject with the first error that was encountered.\n   *\n   * @param iterable - the array of inputs for the callback function\n   * @param callback - a function that starts an asynchronous promise for an element\n   *   from the array\n   * @param options - options for customizing the control flow\n   * @returns an array containing the result for each callback, in the same order\n   *   as the original input `array`\n   */\n  public static async mapAsync<TEntry, TRetVal>(\n    iterable: Iterable<TEntry> | AsyncIterable<TEntry>,\n    callback: (entry: TEntry, arrayIndex: number) => Promise<TRetVal>,\n    options?: IAsyncParallelismOptions | undefined\n  ): Promise<TRetVal[]> {\n    const result: TRetVal[] = [];\n\n    await Async.forEachAsync(\n      iterable,\n      async (item: TEntry, arrayIndex: number): Promise<void> => {\n        result[arrayIndex] = await callback(item, arrayIndex);\n      },\n      options\n    );\n\n    return result;\n  }\n\n  /**\n   * Given an input array and a `callback` function, invoke the callback to start a\n   * promise for each element in the array.\n   *\n   * @remarks\n   * This API is similar to the system `Array#forEach`, except that the loop is asynchronous,\n   * and the maximum number of concurrent promises can be throttled\n   * using {@link IAsyncParallelismOptions.concurrency}.\n   *\n   * If `callback` throws a synchronous exception, or if it returns a promise that rejects,\n   * then the loop stops immediately.  Any remaining array items will be skipped, and\n   * overall operation will reject with the first error that was encountered.\n   *\n   * @param iterable - the array of inputs for the callback function\n   * @param callback - a function that starts an asynchronous promise for an element\n   *   from the array\n   * @param options - options for customizing the control flow\n   */\n  public static async forEachAsync<TEntry>(\n    iterable: Iterable<TEntry> | AsyncIterable<TEntry>,\n    callback: (entry: TEntry, arrayIndex: number) => Promise<void>,\n    options?: IAsyncParallelismOptions | undefined\n  ): Promise<void> {\n    await new Promise<void>((resolve: () => void, reject: (error: Error) => void) => {\n      const concurrency: number =\n        options?.concurrency && options.concurrency > 0 ? options.concurrency : Infinity;\n      let operationsInProgress: number = 0;\n\n      const iterator: Iterator<TEntry> | AsyncIterator<TEntry> = (\n        (iterable as Iterable<TEntry>)[Symbol.iterator] ||\n        (iterable as AsyncIterable<TEntry>)[Symbol.asyncIterator]\n      ).call(iterable);\n\n      let arrayIndex: number = 0;\n      let iteratorIsComplete: boolean = false;\n      let promiseHasResolvedOrRejected: boolean = false;\n\n      async function queueOperationsAsync(): Promise<void> {\n        while (operationsInProgress < concurrency && !iteratorIsComplete && !promiseHasResolvedOrRejected) {\n          // Increment the concurrency while waiting for the iterator.\n          // This function is reentrant, so this ensures that at most `concurrency` executions are waiting\n          operationsInProgress++;\n          const currentIteratorResult: IteratorResult<TEntry> = await iterator.next();\n          // eslint-disable-next-line require-atomic-updates\n          iteratorIsComplete = !!currentIteratorResult.done;\n\n          if (!iteratorIsComplete) {\n            Promise.resolve(callback(currentIteratorResult.value, arrayIndex++))\n              .then(async () => {\n                operationsInProgress--;\n                await onOperationCompletionAsync();\n              })\n              .catch((error) => {\n                promiseHasResolvedOrRejected = true;\n                reject(error);\n              });\n          } else {\n            // The iterator is complete and there wasn't a value, so untrack the waiting state.\n            operationsInProgress--;\n          }\n        }\n\n        if (iteratorIsComplete) {\n          await onOperationCompletionAsync();\n        }\n      }\n\n      async function onOperationCompletionAsync(): Promise<void> {\n        if (!promiseHasResolvedOrRejected) {\n          if (operationsInProgress === 0 && iteratorIsComplete) {\n            promiseHasResolvedOrRejected = true;\n            resolve();\n          } else if (!iteratorIsComplete) {\n            await queueOperationsAsync();\n          }\n        }\n      }\n\n      queueOperationsAsync().catch((error) => {\n        promiseHasResolvedOrRejected = true;\n        reject(error);\n      });\n    });\n  }\n\n  /**\n   * Return a promise that resolves after the specified number of milliseconds.\n   */\n  public static async sleep(ms: number): Promise<void> {\n    await new Promise((resolve) => {\n      setTimeout(resolve, ms);\n    });\n  }\n}\n"]}
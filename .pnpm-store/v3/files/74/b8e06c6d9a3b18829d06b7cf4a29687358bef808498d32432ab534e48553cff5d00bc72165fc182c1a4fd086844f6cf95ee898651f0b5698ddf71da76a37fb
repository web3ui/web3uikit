{"version":3,"file":"ApiModelGenerator.js","sourceRoot":"","sources":["../../src/generators/ApiModelGenerator.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\n/* eslint-disable no-bitwise */\n\nimport * as ts from 'typescript';\nimport * as tsdoc from '@microsoft/tsdoc';\nimport {\n  ApiModel,\n  ApiClass,\n  ApiPackage,\n  ApiEntryPoint,\n  ApiMethod,\n  ApiNamespace,\n  ApiInterface,\n  ApiPropertySignature,\n  ApiItemContainerMixin,\n  ReleaseTag,\n  ApiProperty,\n  ApiMethodSignature,\n  IApiParameterOptions,\n  ApiEnum,\n  ApiEnumMember,\n  IExcerptTokenRange,\n  IExcerptToken,\n  ApiConstructor,\n  ApiConstructSignature,\n  ApiFunction,\n  ApiIndexSignature,\n  ApiVariable,\n  ApiTypeAlias,\n  ApiCallSignature,\n  IApiTypeParameterOptions\n} from '@microsoft/api-extractor-model';\n\nimport { Collector } from '../collector/Collector';\nimport { AstDeclaration } from '../analyzer/AstDeclaration';\nimport { ExcerptBuilder, IExcerptBuilderNodeToCapture } from './ExcerptBuilder';\nimport { AstSymbol } from '../analyzer/AstSymbol';\nimport { DeclarationReferenceGenerator } from './DeclarationReferenceGenerator';\nimport { ApiItemMetadata } from '../collector/ApiItemMetadata';\nimport { DeclarationMetadata } from '../collector/DeclarationMetadata';\nimport { AstNamespaceImport } from '../analyzer/AstNamespaceImport';\nimport { AstEntity } from '../analyzer/AstEntity';\nimport { AstModule } from '../analyzer/AstModule';\n\nexport class ApiModelGenerator {\n  private readonly _collector: Collector;\n  private readonly _apiModel: ApiModel;\n  private readonly _referenceGenerator: DeclarationReferenceGenerator;\n\n  public constructor(collector: Collector) {\n    this._collector = collector;\n    this._apiModel = new ApiModel();\n    this._referenceGenerator = new DeclarationReferenceGenerator(\n      collector.packageJsonLookup,\n      collector.workingPackage.name,\n      collector.program,\n      collector.typeChecker,\n      collector.bundledPackageNames\n    );\n  }\n\n  public get apiModel(): ApiModel {\n    return this._apiModel;\n  }\n\n  public buildApiPackage(): ApiPackage {\n    const packageDocComment: tsdoc.DocComment | undefined = this._collector.workingPackage.tsdocComment;\n\n    const apiPackage: ApiPackage = new ApiPackage({\n      name: this._collector.workingPackage.name,\n      docComment: packageDocComment,\n      tsdocConfiguration: this._collector.extractorConfig.tsdocConfiguration\n    });\n    this._apiModel.addMember(apiPackage);\n\n    const apiEntryPoint: ApiEntryPoint = new ApiEntryPoint({ name: '' });\n    apiPackage.addMember(apiEntryPoint);\n\n    // Create a CollectorEntity for each top-level export\n    for (const entity of this._collector.entities) {\n      if (entity.exported) {\n        this._processAstEntity(entity.astEntity, entity.nameForEmit, apiEntryPoint);\n      }\n    }\n\n    return apiPackage;\n  }\n\n  private _processAstEntity(\n    astEntity: AstEntity,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    if (astEntity instanceof AstSymbol) {\n      // Skip ancillary declarations; we will process them with the main declaration\n      for (const astDeclaration of this._collector.getNonAncillaryDeclarations(astEntity)) {\n        this._processDeclaration(astDeclaration, exportedName, parentApiItem);\n      }\n      return;\n    }\n\n    if (astEntity instanceof AstNamespaceImport) {\n      // Note that a single API item can belong to two different AstNamespaceImport namespaces.  For example:\n      //\n      //   // file.ts defines \"thing()\"\n      //   import * as example1 from \"./file\";\n      //   import * as example2 from \"./file\";\n      //\n      //   // ...so here we end up with example1.thing() and example2.thing()\n      //   export { example1, example2 }\n      //\n      // The current logic does not try to associate \"thing()\" with a specific parent.  Instead\n      // the API documentation will show duplicated entries for example1.thing() and example2.thing()./\n      //\n      // This could be improved in the future, but it requires a stable mechanism for choosing an associated parent.\n      // For thoughts about this:  https://github.com/microsoft/rushstack/issues/1308\n      this._processAstModule(astEntity.astModule, exportedName, parentApiItem);\n      return;\n    }\n\n    // TODO: Figure out how to represent reexported AstImport objects.  Basically we need to introduce a new\n    // ApiItem subclass for \"export alias\", similar to a type alias, but representing declarations of the\n    // form \"export { X } from 'external-package'\".  We can also use this to solve GitHub issue #950.\n  }\n\n  private _processAstModule(\n    astModule: AstModule,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const name: string = exportedName ? exportedName : astModule.moduleSymbol.name;\n    const containerKey: string = ApiNamespace.getContainerKey(name);\n\n    let apiNamespace: ApiNamespace | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiNamespace;\n\n    if (apiNamespace === undefined) {\n      apiNamespace = new ApiNamespace({\n        name,\n        docComment: undefined,\n        releaseTag: ReleaseTag.None,\n        excerptTokens: []\n      });\n      parentApiItem.addMember(apiNamespace);\n    }\n\n    astModule.astModuleExportInfo!.exportedLocalEntities.forEach(\n      (exportedEntity: AstEntity, exportedName: string) => {\n        this._processAstEntity(exportedEntity, exportedName, apiNamespace!);\n      }\n    );\n  }\n\n  private _processDeclaration(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    if ((astDeclaration.modifierFlags & ts.ModifierFlags.Private) !== 0) {\n      return; // trim out private declarations\n    }\n\n    const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n    const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n    if (releaseTag === ReleaseTag.Internal || releaseTag === ReleaseTag.Alpha) {\n      return; // trim out items marked as \"@internal\" or \"@alpha\"\n    }\n\n    switch (astDeclaration.declaration.kind) {\n      case ts.SyntaxKind.CallSignature:\n        this._processApiCallSignature(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.Constructor:\n        this._processApiConstructor(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.ConstructSignature:\n        this._processApiConstructSignature(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.ClassDeclaration:\n        this._processApiClass(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.EnumDeclaration:\n        this._processApiEnum(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.EnumMember:\n        this._processApiEnumMember(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.FunctionDeclaration:\n        this._processApiFunction(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.GetAccessor:\n        this._processApiProperty(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.SetAccessor:\n        this._processApiProperty(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.IndexSignature:\n        this._processApiIndexSignature(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.InterfaceDeclaration:\n        this._processApiInterface(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.MethodDeclaration:\n        this._processApiMethod(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.MethodSignature:\n        this._processApiMethodSignature(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.ModuleDeclaration:\n        this._processApiNamespace(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.PropertyDeclaration:\n        this._processApiProperty(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.PropertySignature:\n        this._processApiPropertySignature(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.TypeAliasDeclaration:\n        this._processApiTypeAlias(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      case ts.SyntaxKind.VariableDeclaration:\n        this._processApiVariable(astDeclaration, exportedName, parentApiItem);\n        break;\n\n      default:\n      // ignore unknown types\n    }\n  }\n\n  private _processChildDeclarations(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    for (const childDeclaration of astDeclaration.children) {\n      this._processDeclaration(childDeclaration, undefined, parentApiItem);\n    }\n  }\n\n  private _processApiCallSignature(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiCallSignature.getContainerKey(overloadIndex);\n\n    let apiCallSignature: ApiCallSignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiCallSignature;\n\n    if (apiCallSignature === undefined) {\n      const callSignature: ts.CallSignatureDeclaration =\n        astDeclaration.declaration as ts.CallSignatureDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: callSignature.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        callSignature.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        callSignature.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      apiCallSignature = new ApiCallSignature({\n        docComment,\n        releaseTag,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange\n      });\n\n      parentApiItem.addMember(apiCallSignature);\n    }\n  }\n\n  private _processApiConstructor(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiConstructor.getContainerKey(overloadIndex);\n\n    let apiConstructor: ApiConstructor | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiConstructor;\n\n    if (apiConstructor === undefined) {\n      const constructorDeclaration: ts.ConstructorDeclaration =\n        astDeclaration.declaration as ts.ConstructorDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        constructorDeclaration.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      apiConstructor = new ApiConstructor({\n        docComment,\n        releaseTag,\n        parameters,\n        overloadIndex,\n        excerptTokens\n      });\n\n      parentApiItem.addMember(apiConstructor);\n    }\n  }\n\n  private _processApiClass(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const name: string = exportedName ? exportedName : astDeclaration.astSymbol.localName;\n    const containerKey: string = ApiClass.getContainerKey(name);\n\n    let apiClass: ApiClass | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiClass;\n\n    if (apiClass === undefined) {\n      const classDeclaration: ts.ClassDeclaration = astDeclaration.declaration as ts.ClassDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        classDeclaration.typeParameters\n      );\n\n      let extendsTokenRange: IExcerptTokenRange | undefined = undefined;\n      const implementsTokenRanges: IExcerptTokenRange[] = [];\n\n      for (const heritageClause of classDeclaration.heritageClauses || []) {\n        if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {\n          extendsTokenRange = ExcerptBuilder.createEmptyTokenRange();\n          if (heritageClause.types.length > 0) {\n            nodesToCapture.push({ node: heritageClause.types[0], tokenRange: extendsTokenRange });\n          }\n        } else if (heritageClause.token === ts.SyntaxKind.ImplementsKeyword) {\n          for (const heritageType of heritageClause.types) {\n            const implementsTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n            implementsTokenRanges.push(implementsTokenRange);\n            nodesToCapture.push({ node: heritageType, tokenRange: implementsTokenRange });\n          }\n        }\n      }\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      apiClass = new ApiClass({\n        name,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        typeParameters,\n        extendsTokenRange,\n        implementsTokenRanges\n      });\n\n      parentApiItem.addMember(apiClass);\n    }\n\n    this._processChildDeclarations(astDeclaration, exportedName, apiClass);\n  }\n\n  private _processApiConstructSignature(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiConstructSignature.getContainerKey(overloadIndex);\n\n    let apiConstructSignature: ApiConstructSignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiConstructSignature;\n\n    if (apiConstructSignature === undefined) {\n      const constructSignature: ts.ConstructSignatureDeclaration =\n        astDeclaration.declaration as ts.ConstructSignatureDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: constructSignature.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        constructSignature.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        constructSignature.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      apiConstructSignature = new ApiConstructSignature({\n        docComment,\n        releaseTag,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange\n      });\n\n      parentApiItem.addMember(apiConstructSignature);\n    }\n  }\n\n  private _processApiEnum(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const name: string = exportedName ? exportedName : astDeclaration.astSymbol.localName;\n    const containerKey: string = ApiEnum.getContainerKey(name);\n\n    let apiEnum: ApiEnum | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiEnum;\n\n    if (apiEnum === undefined) {\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, []);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      apiEnum = new ApiEnum({ name, docComment, releaseTag, excerptTokens });\n      parentApiItem.addMember(apiEnum);\n    }\n\n    this._processChildDeclarations(astDeclaration, exportedName, apiEnum);\n  }\n\n  private _processApiEnumMember(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const name: string = exportedName ? exportedName : astDeclaration.astSymbol.localName;\n    const containerKey: string = ApiEnumMember.getContainerKey(name);\n\n    let apiEnumMember: ApiEnumMember | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiEnumMember;\n\n    if (apiEnumMember === undefined) {\n      const enumMember: ts.EnumMember = astDeclaration.declaration as ts.EnumMember;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const initializerTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: enumMember.initializer, tokenRange: initializerTokenRange });\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      apiEnumMember = new ApiEnumMember({\n        name,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        initializerTokenRange\n      });\n\n      parentApiItem.addMember(apiEnumMember);\n    }\n  }\n\n  private _processApiFunction(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const name: string = exportedName ? exportedName : astDeclaration.astSymbol.localName;\n\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiFunction.getContainerKey(name, overloadIndex);\n\n    let apiFunction: ApiFunction | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiFunction;\n\n    if (apiFunction === undefined) {\n      const functionDeclaration: ts.FunctionDeclaration =\n        astDeclaration.declaration as ts.FunctionDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: functionDeclaration.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        functionDeclaration.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        functionDeclaration.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      if (releaseTag === ReleaseTag.Internal || releaseTag === ReleaseTag.Alpha) {\n        return; // trim out items marked as \"@internal\" or \"@alpha\"\n      }\n\n      apiFunction = new ApiFunction({\n        name,\n        docComment,\n        releaseTag,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange\n      });\n\n      parentApiItem.addMember(apiFunction);\n    }\n  }\n\n  private _processApiIndexSignature(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiIndexSignature.getContainerKey(overloadIndex);\n\n    let apiIndexSignature: ApiIndexSignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiIndexSignature;\n\n    if (apiIndexSignature === undefined) {\n      const indexSignature: ts.IndexSignatureDeclaration =\n        astDeclaration.declaration as ts.IndexSignatureDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: indexSignature.type, tokenRange: returnTypeTokenRange });\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        indexSignature.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      apiIndexSignature = new ApiIndexSignature({\n        docComment,\n        releaseTag,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange\n      });\n\n      parentApiItem.addMember(apiIndexSignature);\n    }\n  }\n\n  private _processApiInterface(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const name: string = exportedName ? exportedName : astDeclaration.astSymbol.localName;\n    const containerKey: string = ApiInterface.getContainerKey(name);\n\n    let apiInterface: ApiInterface | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiInterface;\n\n    if (apiInterface === undefined) {\n      const interfaceDeclaration: ts.InterfaceDeclaration =\n        astDeclaration.declaration as ts.InterfaceDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        interfaceDeclaration.typeParameters\n      );\n\n      const extendsTokenRanges: IExcerptTokenRange[] = [];\n\n      for (const heritageClause of interfaceDeclaration.heritageClauses || []) {\n        if (heritageClause.token === ts.SyntaxKind.ExtendsKeyword) {\n          for (const heritageType of heritageClause.types) {\n            const extendsTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n            extendsTokenRanges.push(extendsTokenRange);\n            nodesToCapture.push({ node: heritageType, tokenRange: extendsTokenRange });\n          }\n        }\n      }\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      apiInterface = new ApiInterface({\n        name,\n        docComment,\n        releaseTag,\n        excerptTokens,\n        typeParameters,\n        extendsTokenRanges\n      });\n\n      parentApiItem.addMember(apiInterface);\n    }\n\n    this._processChildDeclarations(astDeclaration, exportedName, apiInterface);\n  }\n\n  private _processApiMethod(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const name: string = exportedName ? exportedName : astDeclaration.astSymbol.localName;\n\n    const isStatic: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Static) !== 0;\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiMethod.getContainerKey(name, isStatic, overloadIndex);\n\n    let apiMethod: ApiMethod | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiMethod;\n\n    if (apiMethod === undefined) {\n      const methodDeclaration: ts.MethodDeclaration = astDeclaration.declaration as ts.MethodDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: methodDeclaration.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        methodDeclaration.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        methodDeclaration.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      if (releaseTag === ReleaseTag.Internal || releaseTag === ReleaseTag.Alpha) {\n        return; // trim out items marked as \"@internal\" or \"@alpha\"\n      }\n      const isOptional: boolean =\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\n\n      apiMethod = new ApiMethod({\n        name,\n        docComment,\n        releaseTag,\n        isStatic,\n        isOptional,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange\n      });\n\n      parentApiItem.addMember(apiMethod);\n    }\n  }\n\n  private _processApiMethodSignature(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const name: string = exportedName ? exportedName : astDeclaration.astSymbol.localName;\n\n    const overloadIndex: number = this._collector.getOverloadIndex(astDeclaration);\n    const containerKey: string = ApiMethodSignature.getContainerKey(name, overloadIndex);\n\n    let apiMethodSignature: ApiMethodSignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiMethodSignature;\n\n    if (apiMethodSignature === undefined) {\n      const methodSignature: ts.MethodSignature = astDeclaration.declaration as ts.MethodSignature;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const returnTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: methodSignature.type, tokenRange: returnTypeTokenRange });\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        methodSignature.typeParameters\n      );\n\n      const parameters: IApiParameterOptions[] = this._captureParameters(\n        nodesToCapture,\n        methodSignature.parameters\n      );\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isOptional: boolean =\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\n\n      apiMethodSignature = new ApiMethodSignature({\n        name,\n        docComment,\n        releaseTag,\n        isOptional,\n        typeParameters,\n        parameters,\n        overloadIndex,\n        excerptTokens,\n        returnTypeTokenRange\n      });\n\n      parentApiItem.addMember(apiMethodSignature);\n    }\n  }\n\n  private _processApiNamespace(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const name: string = exportedName ? exportedName : astDeclaration.astSymbol.localName;\n    const containerKey: string = ApiNamespace.getContainerKey(name);\n\n    let apiNamespace: ApiNamespace | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiNamespace;\n\n    if (apiNamespace === undefined) {\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, []);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      apiNamespace = new ApiNamespace({ name, docComment, releaseTag, excerptTokens });\n      parentApiItem.addMember(apiNamespace);\n    }\n\n    this._processChildDeclarations(astDeclaration, exportedName, apiNamespace);\n  }\n\n  private _processApiProperty(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const name: string = exportedName ? exportedName : astDeclaration.astSymbol.localName;\n\n    const isStatic: boolean = (astDeclaration.modifierFlags & ts.ModifierFlags.Static) !== 0;\n\n    const containerKey: string = ApiProperty.getContainerKey(name, isStatic);\n\n    let apiProperty: ApiProperty | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiProperty;\n\n    if (apiProperty === undefined) {\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const propertyTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      let propertyTypeNode: ts.TypeNode | undefined;\n\n      if (\n        ts.isPropertyDeclaration(astDeclaration.declaration) ||\n        ts.isGetAccessorDeclaration(astDeclaration.declaration)\n      ) {\n        propertyTypeNode = astDeclaration.declaration.type;\n      }\n\n      if (ts.isSetAccessorDeclaration(astDeclaration.declaration)) {\n        // Note that TypeScript always reports an error if a setter does not have exactly one parameter.\n        propertyTypeNode = astDeclaration.declaration.parameters[0].type;\n      }\n\n      nodesToCapture.push({ node: propertyTypeNode, tokenRange: propertyTypeTokenRange });\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isOptional: boolean =\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\n\n      apiProperty = new ApiProperty({\n        name,\n        docComment,\n        releaseTag,\n        isStatic,\n        isOptional,\n        excerptTokens,\n        propertyTypeTokenRange\n      });\n      parentApiItem.addMember(apiProperty);\n    } else {\n      // If the property was already declared before (via a merged interface declaration),\n      // we assume its signature is identical, because the language requires that.\n    }\n  }\n\n  private _processApiPropertySignature(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const name: string = exportedName ? exportedName : astDeclaration.astSymbol.localName;\n    const containerKey: string = ApiPropertySignature.getContainerKey(name);\n\n    let apiPropertySignature: ApiPropertySignature | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiPropertySignature;\n\n    if (apiPropertySignature === undefined) {\n      const propertySignature: ts.PropertySignature = astDeclaration.declaration as ts.PropertySignature;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const propertyTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: propertySignature.type, tokenRange: propertyTypeTokenRange });\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n      const isOptional: boolean =\n        (astDeclaration.astSymbol.followedSymbol.flags & ts.SymbolFlags.Optional) !== 0;\n\n      apiPropertySignature = new ApiPropertySignature({\n        name,\n        docComment,\n        releaseTag,\n        isOptional,\n        excerptTokens,\n        propertyTypeTokenRange\n      });\n\n      parentApiItem.addMember(apiPropertySignature);\n    } else {\n      // If the property was already declared before (via a merged interface declaration),\n      // we assume its signature is identical, because the language requires that.\n    }\n  }\n\n  private _processApiTypeAlias(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const name: string = exportedName ? exportedName : astDeclaration.astSymbol.localName;\n\n    const containerKey: string = ApiTypeAlias.getContainerKey(name);\n\n    let apiTypeAlias: ApiTypeAlias | undefined = parentApiItem.tryGetMemberByKey(\n      containerKey\n    ) as ApiTypeAlias;\n\n    if (apiTypeAlias === undefined) {\n      const typeAliasDeclaration: ts.TypeAliasDeclaration =\n        astDeclaration.declaration as ts.TypeAliasDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const typeParameters: IApiTypeParameterOptions[] = this._captureTypeParameters(\n        nodesToCapture,\n        typeAliasDeclaration.typeParameters\n      );\n\n      const typeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: typeAliasDeclaration.type, tokenRange: typeTokenRange });\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      apiTypeAlias = new ApiTypeAlias({\n        name,\n        docComment,\n        typeParameters,\n        releaseTag,\n        excerptTokens,\n        typeTokenRange\n      });\n\n      parentApiItem.addMember(apiTypeAlias);\n    }\n  }\n\n  private _processApiVariable(\n    astDeclaration: AstDeclaration,\n    exportedName: string | undefined,\n    parentApiItem: ApiItemContainerMixin\n  ): void {\n    const name: string = exportedName ? exportedName : astDeclaration.astSymbol.localName;\n\n    const containerKey: string = ApiVariable.getContainerKey(name);\n\n    let apiVariable: ApiVariable | undefined = parentApiItem.tryGetMemberByKey(containerKey) as ApiVariable;\n\n    if (apiVariable === undefined) {\n      const variableDeclaration: ts.VariableDeclaration =\n        astDeclaration.declaration as ts.VariableDeclaration;\n\n      const nodesToCapture: IExcerptBuilderNodeToCapture[] = [];\n\n      const variableTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: variableDeclaration.type, tokenRange: variableTypeTokenRange });\n\n      const excerptTokens: IExcerptToken[] = this._buildExcerptTokens(astDeclaration, nodesToCapture);\n      const apiItemMetadata: ApiItemMetadata = this._collector.fetchApiItemMetadata(astDeclaration);\n      const docComment: tsdoc.DocComment | undefined = apiItemMetadata.tsdocComment;\n      const releaseTag: ReleaseTag = apiItemMetadata.effectiveReleaseTag;\n\n      apiVariable = new ApiVariable({ name, docComment, releaseTag, excerptTokens, variableTypeTokenRange });\n\n      parentApiItem.addMember(apiVariable);\n    }\n  }\n\n  /**\n   * @param nodesToCapture - A list of child nodes whose token ranges we want to capture\n   */\n  private _buildExcerptTokens(\n    astDeclaration: AstDeclaration,\n    nodesToCapture: IExcerptBuilderNodeToCapture[]\n  ): IExcerptToken[] {\n    const excerptTokens: IExcerptToken[] = [];\n\n    // Build the main declaration\n    ExcerptBuilder.addDeclaration(excerptTokens, astDeclaration, nodesToCapture, this._referenceGenerator);\n\n    const declarationMetadata: DeclarationMetadata = this._collector.fetchDeclarationMetadata(astDeclaration);\n\n    // Add any ancillary declarations\n    for (const ancillaryDeclaration of declarationMetadata.ancillaryDeclarations) {\n      ExcerptBuilder.addBlankLine(excerptTokens);\n      ExcerptBuilder.addDeclaration(\n        excerptTokens,\n        ancillaryDeclaration,\n        nodesToCapture,\n        this._referenceGenerator\n      );\n    }\n\n    return excerptTokens;\n  }\n\n  private _captureTypeParameters(\n    nodesToCapture: IExcerptBuilderNodeToCapture[],\n    typeParameterNodes: ts.NodeArray<ts.TypeParameterDeclaration> | undefined\n  ): IApiTypeParameterOptions[] {\n    const typeParameters: IApiTypeParameterOptions[] = [];\n    if (typeParameterNodes) {\n      for (const typeParameter of typeParameterNodes) {\n        const constraintTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n        nodesToCapture.push({ node: typeParameter.constraint, tokenRange: constraintTokenRange });\n\n        const defaultTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n        nodesToCapture.push({ node: typeParameter.default, tokenRange: defaultTypeTokenRange });\n\n        typeParameters.push({\n          typeParameterName: typeParameter.name.getText().trim(),\n          constraintTokenRange,\n          defaultTypeTokenRange\n        });\n      }\n    }\n    return typeParameters;\n  }\n\n  private _captureParameters(\n    nodesToCapture: IExcerptBuilderNodeToCapture[],\n    parameterNodes: ts.NodeArray<ts.ParameterDeclaration>\n  ): IApiParameterOptions[] {\n    const parameters: IApiParameterOptions[] = [];\n    for (const parameter of parameterNodes) {\n      const parameterTypeTokenRange: IExcerptTokenRange = ExcerptBuilder.createEmptyTokenRange();\n      nodesToCapture.push({ node: parameter.type, tokenRange: parameterTypeTokenRange });\n      parameters.push({\n        parameterName: parameter.name.getText().trim(),\n        parameterTypeTokenRange,\n        isOptional: this._collector.typeChecker.isOptionalParameter(parameter)\n      });\n    }\n    return parameters;\n  }\n}\n"]}
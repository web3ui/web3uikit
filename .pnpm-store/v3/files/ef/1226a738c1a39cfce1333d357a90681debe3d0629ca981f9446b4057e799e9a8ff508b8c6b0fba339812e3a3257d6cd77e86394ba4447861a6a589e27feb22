{
  "name": "@rushstack/ts-command-line",
  "version": "4.11.0",
  "description": "An object-oriented command-line parser for TypeScript",
  "repository": {
    "type": "git",
    "url": "https://github.com/microsoft/rushstack.git",
    "directory": "libraries/ts-command-line"
  },
  "main": "lib/index.js",
  "typings": "dist/ts-command-line.d.ts",
  "license": "MIT",
  "dependencies": {
    "@types/argparse": "1.0.38",
    "argparse": "~1.0.9",
    "colors": "~1.2.1",
    "string-argv": "~0.3.1"
  },
  "devDependencies": {
    "@rushstack/eslint-config": "2.6.0",
    "@rushstack/heft": "0.45.1",
    "@rushstack/heft-node-rig": "1.9.2",
    "@types/heft-jest": "1.0.1",
    "@types/node": "12.20.24"
  },
  "scripts": {
    "build": "heft build --clean",
    "_phase:build": "heft build --clean",
    "_phase:test": "heft test --no-build"
  },
  "readme": "# ts-command-line\n\nThis library helps you create professional command-line tools using TypeScript.  By \"professional\", we mean:\n\n- **no gotchas for users**:  Seems obvious, but try typing \"`npm install --save-dex`\" instead of \"`npm install --save-dev`\" sometime.  The command seems to execute successfully, but it doesn't save anything! The misspelled flag was silently ignored. This lack of rigor plagues many familiar Node.js tools and can be confusing and frustrating. For a great user experience, a command line tool should always be strict about its syntax.\n\n- **no gotchas for developers**:  Many command-line libraries store their parsed data in a simple JavaScript object. This is convenient for small projects. But suppose a large project has many different source files that define and read parameters. If you try to read `data['output-dir']` when it wasn't defined, or if you misspell the key name, your tool will silently behave as if the parameter was omitted. And is `data['max-count']` a string or a number? Hard to tell! We solve this by modeling each parameter kind as a real TypeScript class.\n\n- **simple by design**:  Making a CLI is similar to making a graphical UI -- some people have a knack for clean and intuitive designs, but your average developer... needs some help.  :-)  Keeping things simple is the best help.  **ts-command-line** intentionally provides a minimalist set of CLI building blocks that encourage simple designs.  If your app has lots of knobs and switches, we recommend NOT to design a complex CLI with hundreds of parameters.  Move those options into a commented config file with a published JSON schema.\n\n- **automatic documentation**: Some command-line libraries treat the `--help` docs as someone else's job.  **ts-command-line** requires each every parameter to follow a standardized naming pattern and have a documentation string.  It will automatically generate the `--help` docs for you.  If you like to write long paragraphs, no problem -- they will be word-wrapped correctly. *[golf clap]*\n\n- **structure and extensibility**: Instead of a simple function chain, **ts-command-line** provides a \"scaffold\" pattern that makes it easy to find and understand the command-line implementation for any tool project.  The scaffold model is generally recommended, but there's also a \"dynamic\" model if you need it.  See below for examples.\n\n- **environment variable mappings**: Any CLI parameter can be associated with an environment variable.  If the parameter is not explicitly provided, the value from the environment will be used.  The associated environment variables are automatically documented in the `--help`.\n\nInternally, the implementation is based on [argparse](https://www.npmjs.com/package/argparse) and the Python approach to command-lines.\n\nCompared to other libraries, **ts-command-line** doesn't provide zillions of custom syntaxes and bells and whistles.  Instead it aims to be a simple, consistent, and professional solution for your command-line tool.  Give it a try!\n\n### Some Terminology\n\nSuppose that we want to parse a command-line like this:\n\n```\nwidget --verbose push --force --max-count 123\n```\n\nIn this example, we can identify the following components:\n\n- The **tool name** in this example is `widget`.  This is the name of your Node.js bin script.\n- The **parameters** are  `--verbose`, `--force`, and `--max-count`.\n- The value \"123\" is the **argument** for the `--max-count` integer parameter.  (Flags don't have arguments, because their value is determined by whether the flag was provided or not.)\n- Similar to Git's command-line, the `push` token is called an **action**.  It acts as sub-command with its own unique set of parameters.\n- The `--verbose` flag is a **global parameter** because it precedes the action name.  It affects all actions.\n- The `--force` flag is an **action parameter** because it comes after the action name.  It only applies to that action.\n\n\n### Parameter Kinds\n\nSeveral different kinds of parameters are supported:\n\n| Parameter Kind | Example | Data Type | Description |\n| --- | --- | --- | --- |\n| flag | `--verbose` | `boolean` | Value is `true` if the flag was specified on the command line, `false` otherwise. |\n| integer | `--max-retry 3` | `int` | The argument is an integer number |\n| string | `--title \"Hello, world\"` | `string` | The argument is a text string. |\n| choice | `--color red` | `string` | The argument is must be a string from a list of allowed choices (similar to an enum). |\n| string list | `-o file1.txt -o file2.txt` | `string[]` | The argument is a text string. The parameter can be specified multiple times to build a list. |\n\nOther parameter kinds could be implemented if requested.  That said, keeping your CLI grammar simple and systematic makes it easier for users to learn.\n\n\n## Scaffold Model\n\nIf your tool uses the scaffold model, you will create subclasses of two abstract base classes:  `CommandLineParser` for the overall command-line, and `CommandLineAction` for each action.\n\nContinuing our example from above, suppose we want to start with a couple simple flags like this:\n\n```\nwidget --verbose push --force\n```\n\nWe could define our subclass for the \"`push`\" action like this:\n\n```typescript\nexport class PushAction extends CommandLineAction {\n  private _force: CommandLineFlagParameter;\n  private _protocol: CommandLineChoiceParameter;\n\n  public constructor() {\n    super({\n      actionName: 'push',\n      summary: 'Pushes a widget to the service',\n      documentation: 'Here we provide a longer description of how our action works.'\n    });\n  }\n\n  protected onExecute(): Promise<void> { // abstract\n    return BusinessLogic.doTheWork(this._force.value, this._protocol.value || \"(none)\");\n  }\n\n  protected onDefineParameters(): void { // abstract\n    this._force = this.defineFlagParameter({\n      parameterLongName: '--force',\n      parameterShortName: '-f',\n      description: 'Push and overwrite any existing state'\n    });\n\n    this._protocol = this.defineChoiceParameter({\n      parameterLongName: '--protocol',\n      description: 'Specify the protocol to use',\n      alternatives: ['ftp', 'webdav', 'scp'],\n      environmentVariable: 'WIDGET_PROTOCOL',\n      defaultValue: 'scp'\n    });\n  }\n}\n```\n\nThen we might define the parser subclass like this:\n\n```typescript\nexport class WidgetCommandLine extends CommandLineParser {\n  private _verbose: CommandLineFlagParameter;\n\n  public constructor() {\n    super({\n      toolFilename: 'widget',\n      toolDescription: 'The \"widget\" tool is a code sample for using the @rushstack/ts-command-line library.'\n    });\n\n    this.addAction(new PushAction());\n  }\n\n  protected onDefineParameters(): void { // abstract\n    this._verbose = this.defineFlagParameter({\n      parameterLongName: '--verbose',\n      parameterShortName: '-v',\n      description: 'Show extra logging detail'\n    });\n  }\n\n  protected onExecute(): Promise<void> { // override\n    BusinessLogic.configureLogger(this._verbose.value);\n    return super.onExecute();\n  }\n}\n```\n\nTo invoke the parser, the application entry point will do something like this:\n\n```typescript\nconst commandLine: WidgetCommandLine = new WidgetCommandLine();\ncommandLine.execute();\n```\n\nWhen we run `widget --verbose push --force`, the `PushAction.onExecute()` method will get invoked and then your business logic takes over.\n\n---\n\n**For a more complete example, take a look at the [ts-command-line-test](https://github.com/microsoft/rushstack/tree/main/build-tests/ts-command-line-test) sample project.**\n\n---\n\n#### Testing out the docs\n\nIf you invoke the tool as \"`widget --help`\", the docs are automatically generated:\n\n```\nusage: widget [-h] [-v] <command> ...\n\nThe \"widget\" tool is a code sample for using the @rushstack/ts-command-line\nlibrary.\n\nPositional arguments:\n  <command>\n    push         Pushes a widget to the service\n\nOptional arguments:\n  -h, --help     Show this help message and exit.\n  -v, --verbose  Show extra logging detail\n\nFor detailed help about a specific command, use: widget <command> -h\n```\n\nFor help about the `push` action, the user can type \"`widget push --help`\", which shows this output:\n\n```\nusage: widget push [-h] [-f] [--protocol {ftp,webdav,scp}]\n\nHere we provide a longer description of how our action works.\n\nOptional arguments:\n  -h, --help            Show this help message and exit.\n  -f, --force           Push and overwrite any existing state\n  --protocol {ftp,webdav,scp}\n                        Specify the protocol to use. This parameter may\n                        alternatively specified via the WIDGET_PROTOCOL\n                        environment variable. The default value is \"scp\".\n```\n\n## Dynamic Model\n\nThe action subclasses provide a simple, recognizable pattern that you can use across all your tooling projects. It's the generally recommended approach. However, there are some cases where we need to break out of the scaffold.  For example:\n\n- Actions or parameters may be discovered at runtime, e.g. from a config file\n- The actions and their implementations may sometimes have very different structures\n\nIn this case, you can use the `DynamicCommandLineAction` and `DynamicCommandLineParser`  classes which are not abstract (and not intended to be subclassed).  Here's our above example rewritten for this model:\n\n```typescript\n// Define the parser\nconst commandLineParser: DynamicCommandLineParser = new DynamicCommandLineParser({\n  toolFilename: 'widget',\n  toolDescription: 'The \"widget\" tool is a code sample for using the @rushstack/ts-command-line library.'\n});\n\ncommandLineParser.defineFlagParameter({\n  parameterLongName: '--verbose',\n  parameterShortName: '-v',\n  description: 'Show extra logging detail'\n});\n\n// Define the action\nconst action: DynamicCommandLineAction = new DynamicCommandLineAction({\n  actionName: 'push',\n  summary: 'Pushes a widget to the service',\n  documentation: 'Here we provide a longer description of how our action works.'\n});\n\ncommandLineParser.addAction(action);\n\naction.defineFlagParameter({\n  parameterLongName: '--force',\n  parameterShortName: '-f',\n  description: 'Push and overwrite any existing state'\n});\n\naction.defineChoiceParameter({\n  parameterLongName: '--protocol',\n  description: 'Specify the protocol to use',\n  alternatives: ['ftp', 'webdav', 'scp'],\n  environmentVariable: 'WIDGET_PROTOCOL',\n  defaultValue: 'scp'\n});\n\n// Parse the command line\ncommandLineParser.execute().then(() => {\n  console.log('The action is: ' + commandLineParser.selectedAction!.actionName);\n  console.log('The force flag is: ' + action.getFlagParameter('--force').value);\n});\n```\n\nYou can also mix the two models.  For example, we could augment the `WidgetCommandLine` from the original model by adding `DynamicAction` objects to it.\n\n\n## Links\n\n- [CHANGELOG.md](\n  https://github.com/microsoft/rushstack/blob/main/libraries/ts-command-line/CHANGELOG.md) - Find\n  out what's new in the latest version\n- [API Reference](https://rushstack.io/pages/api/ts-command-line/)\n\nHere are some real world GitHub projects that illustrate different use cases for **ts-command-line**:\n\n- [@microsoft/rush](https://www.npmjs.com/package/@microsoft/rush)\n- [@microsoft/api-extractor](https://www.npmjs.com/package/@microsoft/api-extractor)\n- [@microsoft/api-documenter](https://www.npmjs.com/package/@microsoft/api-documenter)\n\n`@rushstack/ts-command-line` is part of the [Rush Stack](https://rushstack.io/) family of projects.\n"
}